# Cursor Rules for Warden

## How to Invoke

User must explicitly reference "Warden" for Cursor to use this skill:

**Correct**:
- "Run the Warden skill"
- "Execute Warden on my PRs"

**Required**: Have Warden repository in workspace so Cursor reads this .cursorrules file.

## About Warden

Warden v1.2: Cross-platform AI skill for comprehensive automated PR review and fixes with contextual review, 50+ configuration parameters, and 1.2-1.7x performance improvement.

## Execution Mode

**THIS IS NOT CONCEPTUAL REVIEW** - You actually execute commands and check exit codes.

- ✅ Checkout PR branches, run build/lint/test commands, check exit codes, fix failures, push fixes
- ❌ NOT: Abstract "review against principles" analysis without running tools

See [docs/COMMANDS.md](docs/COMMANDS.md) for command discovery details.

## Three Issue Sources

Warden analyzes and fixes issues from:
1. **CI failures** - Test failures, build errors, lint issues
2. **Review comments** - Requested changes, unresolved feedback
3. **Code quality** - Security, performance, architecture issues

## Workflow Overview

6-phase workflow:
1. **Discovery** - Batch API call to list PRs
2. **Analysis** - ALL subagents for ALL PRs analyzing all three issue sources
3. **Planning** - Aggregate all sources, deduplicate, prioritize
4. **User Interaction** - **MANDATORY: Compile report, ask approval, WAIT for response**
5. **Execution** - Fix all issue types, validate (build/lint/test), push
6. **Summary** - Metrics and next steps

See [README.md](README.md) for complete documentation.

## Phase 4: User Interaction (MANDATORY)

**CRITICAL**: Before executing ANY fixes, you MUST:

1. **Consolidate all findings** from Phase 2 analysis (all PRs, all three issue sources)
   - Aggregate CI failures, review comments, and code quality issues
   - Remove duplicates across different sources
   - Enrich with severity (Critical/High/Medium/Low) and complexity

2. **Present comprehensive report** with severity breakdown:
   ```
   === Warden Analysis Report ===

   Found N issues across M PRs:

   PR #123: Feature XYZ
   ├─ Critical (2): [Issue IDs with file:line]
   ├─ High (3): [Issue IDs with file:line]
   └─ Medium (1): [Issue IDs with file:line]

   PR #125: Bug Fix ABC
   └─ High (1): [Issue IDs with file:line]

   Total: X Critical, Y High, Z Medium, W Low
   ```

3. **Ask user for approval** with clear options:
   - "Fix all issues?" (default)
   - "Fix only Critical and High?"
   - "Fix specific PRs only?"
   - "Preview detailed findings first?"
   - "Abort (no changes)"

4. **WAIT for user response** - Do NOT proceed to Phase 5 without explicit approval
   - User may want to review detailed findings
   - User may want to exclude certain PRs or issue types
   - User may want to adjust severity thresholds

**Common mistake**: Jumping directly from Phase 3 (Planning) to Phase 5 (Execution) without user approval. This violates the safety-first design and may make unwanted changes.

## Cursor-Specific Optimizations

### Composer Mode Usage

**Phase 2: Analysis**
- Use Composer to analyze multiple PRs in one context window
- Leverage codebase-wide context for cross-file dependencies

**Phase 5: Execution**
- Use Composer for multi-file edits
- Select all affected files before initiating fixes
- Use "Apply to all" for similar patterns across files

### Codebase Context

**Leverage Cursor's codebase understanding**:
- Cross-reference similar code patterns
- Identify related files not directly changed in PR
- Understand project conventions automatically

### Rules Integration

**Language-specific rules**:
- Cursor automatically applies language-specific formatting
- Respect existing .cursorrules in target repository
- Follow project conventions detected from codebase

## Key Optimizations

**Parallel**: Launch all analysis simultaneously (2.5x faster)
**Incremental**: Fix/test/commit by severity tier, rollback per-tier
**Targeted**: Shallow clones, test only affected packages, format only changed files
**Background**: Non-blocking cleanup

**Performance**: 167s-240s vs 291s = **1.2-1.7x faster** (config-dependent)

## Implementation Guidelines

1. **Use Composer for multi-file analysis and edits**
2. **Leverage codebase-wide context**
3. **Batch API calls** - `gh pr list --json`
4. **Shallow clone** - `--depth=1` (unless `--reuse-workspace`)
5. **Test according to strategy** - Respect `--test-strategy` setting
6. **Incremental fixes** - By severity tier
7. **Never modify user's working directory**
8. **Respect configuration** - All 40+ parameters
9. **Comment on PR** - If `--comment-on-pr` enabled
10. **Apply file filters** - Honor `--ignore-paths` and `--focus-paths`

## Subagent Selection

- **Simple** (1-5 lines): Direct edits in Composer
- **Moderate** (5-20 lines): Composer with focused context
- **Complex** (20+ lines): Composer mode with all affected files
- **Very Complex** (>5 files, architectural): Flag for manual review

## Language Commands

Auto-detect and adapt (only changed files):
- **Go**: `gofmt -s -w`, `go test -v ./package/...`
- **Python**: `black`, `pytest path/ -v`
- **JavaScript/TypeScript**: `prettier --write`, `npm test -- --changedSince=origin/main`
- **Rust**: `cargo fmt`, `cargo test --package`

## Error Handling

**Graceful degradation**, **per-tier rollback**, **continue on failure**

See [AGENTS.md](AGENTS.md) and [README.md](README.md) for full details.
